C51 COMPILER V9.59.0.0   MAIN                                                              12/19/2023 14:53:51 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: D:\software\keil\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /**********************慧净电子智能小车例程************************
   2          *  平台：HJ-C51 HJ-1G HL-1 HJ-3G HJ-C52  + Keil uVision4 + STC89C52 + AT89S52
   3          *  名称：HL-1智能小车超声波程序
   4          *  公司：慧净电子科技有限公司
   5          *  淘宝：http://shop37031453.taobao.com
   6          *  网站：www.hjmcu.com    www.hlmcu.com
   7          *  编写?H
   8          *  日期：2008-8-08
   9          *  修改内容：传感器IO口分别接到P3.2 P3.3 口，每个小车电机参考可能不同，请自己调整参考，以更稳定走黑线
  10          *   QQ : 398115088 121350852
  11          *  晶振:11.0592MHZ
  12          *  说明：免费开源，不提供源代码分析，有问题直接到慧净论坛交流
  13          *  论坛：
  14          *  硬件设置：要有自己动手能力，才能完成实验
  15          *  使用说明：根据下面IO口自己用杜邦线连接各种模块，可以自己修改各种模块IO口
  16          *  需要购买慧净电子智能小车相关模块才能做实验--请直接到慧净网站购买
  17          *  学习建议：请到慧净电子学习网WWW.HJMCU.COM免费下载52课《从零到项目开发学51单片机与C语言技术视频教程》 BT
             -下载3.63G
  18             重点提示：本程序只做参考，不提供技术支持，请自己研究吸收。
  19             *  同时要接好LCD1602 注意调节W1对比度，用电脑USB供电时调大一点，用电池供电时调小一点对比度。
  20          
  21             HL-1与HL-1智能小车底盘接线方法，请一定照做，否则可能不工作，并烧毁小车。
  22          
  23             J3
  24             IN1--接到--实验板上的P1.2
  25             IN2--接到--实验板上的P1.3
  26             EN1--接到--实验板上的P1.4
  27             EN2--接到--实验板上的P1.5
  28             IN3--接到--实验板上的P1.6
  29             IN4--接到--实验板上的P1.7
  30             J4
  31             IN5--接到--实验板上的P2.1
  32             IN6--接到--实验板上的P2.0
  33             J5
  34             OUT1--接到--实验板上的P3.3
  35             OUT2--接到--实验板上的P3.4
  36             OUT3--接到--实验板上的P3.5
  37             OUT4--接到--实验板上的P3.6
  38          
  39             电源接法----请注意核对，一定要100%正确，否则会烧坏HL-1实验板
  40             J17
  41             VCC--接到--实验板上的 TTL V 引脚
  42             GND--接到--实验板上的 TTL G 引脚
  43          ******************************************************************/
  44          // 说明：如果没有LCD1602液晶显示屏的同学，请用杜邦把P0.7引脚接到GND，效果一样。
  45          
  46          #include <intrins.h>
  47          #include "LCD1602display.h"
  48          #include <AT89X52.H>
  49          #include <HJ-4WD_PWM.H>
  50          
  51          // #include "STC12C5A60S2_PWM.h"
  52          #define TX P2_1
  53          #define RX P2_0
  54          sbit DU = P2 ^ 6;
C51 COMPILER V9.59.0.0   MAIN                                                              12/19/2023 14:53:51 PAGE 2   

  55          sbit WE = P2 ^ 7;
  56          #define Forward_L_DATA 190 // 当前进不能走直线的时候，请调节这两个参数，理想的时候是100,100，最大256，最小
             -0。0的时候最慢，256的时候最快
  57          #define Forward_R_DATA 190 // 例如小车前进的时候有点向左拐，说明右边马达转速过快，那可以取一个值大一点，另
             -外一个值小一点，例如 200  190
  58                                                             // 直流电机因为制造上的误差，同一个脉宽下也不一定速度一致的，需要自己手动调节
  59          
  60          // sbit P4_0=0xc0;      //P4口地址
  61          
  62          /*****按照原图接线定义******/
  63          sbit L293D_IN1 = P1 ^ 2;
  64          sbit L293D_IN2 = P1 ^ 3;
  65          sbit L293D_IN3 = P1 ^ 6;
  66          sbit L293D_IN4 = P1 ^ 7;
  67          sbit L293D_EN1 = P1 ^ 4;
  68          sbit L293D_EN2 = P1 ^ 5;
  69          
  70          sbit BUZZ = P2 ^ 3;
  71          
  72          // void cmg88()//关数码管，点阵函数
  73          //{
  74          // DU=1;
  75          // P0=0X00;
  76          // DU=0;
  77          // }
  78          
  79          void Delay400Ms(void); // 延时400毫秒函数
  80          
  81          unsigned char code Range[] = "songzirui666"; // LCD1602显示格式
  82          unsigned char code ASCII[13] = "0123456789.-M";
  83          unsigned char code table[] = "Distance:000.0cm";
  84          unsigned char code table1[] = "!!! Out of range";
  85          
  86          unsigned char disbuff[4] = {0, 0, 0, 0}; // 用于分别存放距离的值0.1mm、mm、cm和m的值
  87          
  88          void Count(void); // 距离计算函数
  89          
  90          // unsigned int  time=0;//用于存放定时器时间值
  91          unsigned long S = 0; // 用于存放距离的值
  92          bit flag = 0;            // 量程溢出标志位
  93          
  94          //========================================================================================================
             -=================
  95          /********距离计算程序***************/
  96          void Conut(void)
  97          {
  98   1              time = TH1 * 256 + TL1;
  99   1              TH1 = 0;
 100   1              TL1 = 0;
 101   1      
 102   1              // 此时time的时间单位决定于晶振的速度，外接晶振为11.0592MHZ时，
 103   1              // time的值为0.54us*time，单位为微秒
 104   1              // 那么1us声波能走多远的距离呢？1s=1000ms=1000000us
 105   1              //  340/1000000=0.00034米
 106   1              // 0.00034米/1000=0.34毫米  也就是1us能走0.34毫米
 107   1              // 但是，我们现在计算的是从超声波发射到反射接收的双路程，
 108   1              // 所以我们将计算的结果除以2才是实际的路程
 109   1      
 110   1              S = time ; // 先算出一共的时间是多少微秒。
 111   1              S = S * 0.17; // 此时计算到的结果为毫米，并且是精确到毫米的后两位了，有两个小数点
 112   1      
 113   1              //=======================================
C51 COMPILER V9.59.0.0   MAIN                                                              12/19/2023 14:53:51 PAGE 3   

 114   1              if ((S >= 5000) || flag == 1) // 超出测量范围
 115   1              {
 116   2                      flag = 0;
 117   2                      DisplayListChar(0, 1, table1);
 118   2              }
 119   1              else
 120   1              {
 121   2                      disbuff[0] = S % 10;
 122   2                      disbuff[1] = S / 10 % 10;
 123   2                      disbuff[2] = S / 100 % 10;
 124   2                      disbuff[3] = S / 1000;
 125   2                      DisplayListChar(0, 1, table);
 126   2                      DisplayOneChar(9, 1, ASCII[disbuff[3]]);
 127   2                      DisplayOneChar(10, 1, ASCII[disbuff[2]]);
 128   2                      DisplayOneChar(11, 1, ASCII[disbuff[1]]);
 129   2                      DisplayOneChar(12, 1, ASCII[10]);
 130   2                      DisplayOneChar(13, 1, ASCII[disbuff[0]]);
 131   2              }
 132   1      }
 133          
 134          /********************************************************/
 135          void zd0() interrupt 3 // T0中断用来计数器溢出,超过测距范围
 136          {
 137   1              flag = 1; // 中断溢出标志
 138   1              RX = 0;
 139   1      }
 140          
 141          /********超声波高电平脉冲宽度计算程序***************/
 142          void Timer_Count(void)
 143          {
 144   1              TR1 = 1; // 开启计数
 145   1              while (RX)
 146   1                      ;        // 当RX为1计数并等待
 147   1              TR1 = 0; // 关闭计数
 148   1              Conut(); // 计算
 149   1      }
 150          /********************************************************/
 151          void StartModule() // 启动模块
 152          {
 153   1              TX = 1; // 启动一次模块
 154   1              Delay10us(2);
 155   1              TX = 0;
 156   1      }
 157          /********************************************************/
 158          
 159          /*************主程序********************/
 160          void main(void)
 161          {
 162   1              unsigned char i;
 163   1              unsigned int a;
 164   1              // cmg88();//关数码管
 165   1              Delay1ms(400); // 启动等待，等LCM讲入工作状态
 166   1              LCMInit();         // LCM初始化
 167   1              Delay1ms(5);   // 延时片刻
 168   1      
 169   1              DisplayListChar(0, 0, Range);
 170   1              DisplayListChar(0, 1, table);
 171   1      
 172   1              //===============================
 173   1              // PWM_ini();
 174   1              //===============================
 175   1      
C51 COMPILER V9.59.0.0   MAIN                                                              12/19/2023 14:53:51 PAGE 4   

 176   1              //=================================
 177   1      B:
 178   1              for (i = 0; i < 50; i++) // 判断K4是否按下
 179   1              {
 180   2                      Delay1ms(1);   // 1ms内判断50次，如果其中有一次被判断到K4(S4)没按下，便重新检测
 181   2                      if (P3_7 != 0) // 当K4（S4）按下时，启动小车
 182   2                              goto B;    // 跳转到标号B，重新检测
 183   2              }
 184   1              // 蜂鸣器响一声
 185   1              BUZZ = 0; // 50次检测K4(S4)确认是按下之后，蜂鸣器发出“滴”声响，然后启动小车。
 186   1              Delay1ms(50);
 187   1              BUZZ = 1;                       // 响50ms后关闭蜂鸣器
 188   1              TMOD = TMOD | 0x10; // 设T0为方式1，GATE=1；
 189   1              EA = 1;                         // 开启总中断
 190   1              TH1 = 0;
 191   1              TL1 = 0;
 192   1              ET1 = 1; // 允许T0中断
 193   1      
 194   1              TH0 = 0XFc; // 1ms定时
 195   1              TL0 = 0X18;
 196   1              TR0 = 1;
 197   1              ET0 = 1;
 198   1      
 199   1              //=======================================================================================================
             -================
 200   1              while (1)
 201   1              {
 202   2      
 203   2                      // 有信号为0  没有信号为1
 204   2      
 205   2                      if (Left_1_led == 0 && Right_1_led == 0)
 206   2                      {
 207   3                              run(); // 调用前进函数
 208   3                      }
 209   2                      if (Right_2_led == 0 && Left_2_led == 0) // 避障两边传感器同时检测到红外
 210   2                      {
 211   3                              stoprun(); // 调用电机停止函数
 212   3                              RX = 1;
 213   3                              StartModule(); // 启动模块
 214   3      
 215   3                              for (a = 951; a > 0; a--)
 216   3                              {
 217   4      
 218   4                                      if (RX == 1)
 219   4                                      {
 220   5                                              Timer_Count(); // 超声波高电平脉冲宽度计算函数
 221   5                                      }
 222   4                              }
 223   3                              delay(1000); 
 224   3                              for (a = 951; a > 0; a--)
 225   3                              {
 226   4      
 227   4                                      if (RX == 1)
 228   4                                      {
 229   5                                              Timer_Count(); // 超声波高电平脉冲宽度计算函数
 230   5                                      }
 231   4                              }
 232   3                              delay(1000); 
 233   3                              return;
 234   3                      }
 235   2                      else
 236   2                      {
C51 COMPILER V9.59.0.0   MAIN                                                              12/19/2023 14:53:51 PAGE 5   

 237   3                              if (Left_1_led == 1 && Right_1_led == 0) // 左边检测到黑线
 238   3                              {
 239   4                                      leftrun(); // 调用小车左转  函数
 240   4                                      run();
 241   4                              }
 242   3      
 243   3                              if (Right_1_led == 1 && Left_1_led == 0) // 右边检测到黑线
 244   3                              {
 245   4                                      rightrun();
 246   4                                      run();
 247   4                              }
 248   3                      }
 249   2              }
 250   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1025    ----
   CONSTANT SIZE    =     60    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     14      10
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
